{"dpp_template_code":"#------IMPORTS-----\r\n#Packages used for analysis\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.widgets import Button\r\nfrom pathlib import Path\r\nimport etabackend.tk.utils as etautils\r\nimport os\r\n\r\nfrom numpy import inf\r\nimport scipy.signal\r\nimport time as t\r\nfrom scipy.signal import chirp, find_peaks, peak_widths\r\nfrom scipy.optimize import curve_fit\r\n\r\n#Packages used for curve fitting\r\nimport lmfit as lm\r\nimport matplotlib.pyplot as plt\r\nfrom lmfit.models import GaussianModel, ConstantModel, SkewedGaussianModel\r\nfrom lmfit import Parameters\r\n\r\n#Packages used for plotting\r\nfrom colour import Color\r\nfrom matplotlib import cm\r\nimport matplotlib.cm as cmx\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\n\r\nimport random\r\n\r\nimport warnings\r\nwarnings.simplefilter('ignore', np.RankWarning)\r\n\r\n\r\n\r\nSTART = t.time()\r\n#---File handling---\r\nfile = Path(file)\r\n\r\n#------ETA PROCESSING-----\r\n\"\"\"\r\nCode block loads the time-tagging data and runs the ETA script to genereate ToF histograms\r\n\"\"\"\r\ncutfile = eta.clips(file)\r\nresult = eta.run({\"timetagger1\":cutfile}, group='quTAG')\r\nhistogram=result[ch_sel] #Selects the intended output from ETA, in this case it returns a 2-d array. The y axis for all ToF histograms. X axis must be recreated seperatly\r\n\r\n#Load some values from the ETA frontend, the values are saved as str and must be converted to intended data types\r\n\r\nbinsize = int(float(binsize))  #The size of the bins the ToF histograms\r\nbins = int(float(bins))    #The number of bins in the histogram\r\n\r\n\r\n#------- Functions to calculate 3D data ----------\r\ndef calcDistance(t_ref,t_signal):\r\n    #calculates the distance between peaks, times are given in picoseconds and result is given in mm\r\n    return 1000*0.5*(t_signal-t_ref)*(10**(-12))*299792458\r\n\r\ndef getDistance(ref_peak, histogram):\r\n    #Returns the distance between the highest peak in the histogram and a reference value that is measured seperatly.\r\n    return calcDistance(binsize*ref_peak, binsize*np.where(histogram == np.amax(histogram))[0][0])\r\n\r\n\r\ndef XYZ(r,thetaX,thetaY):\r\n    #converts the distance data and angle information to cartesian coordinates\r\n    \r\n    z = r/(np.sqrt(1+np.tan(thetaX)**2+np.tan(thetaY)**2))\r\n    y = z*np.tan(thetaY)\r\n    x = z*np.tan(thetaX)\r\n\r\n    return x,y,z\r\n\r\ndef angles(rect,dimX,dimY):\r\n    #rect = [x_max,y_max, x_min, y_min]\r\n    #Calculates the angles of the mirrors as a function of the supplied x_voltages  (Angles are relative to the initial position of the mirror, make sure the alignement is correct)\r\n\r\n    x_voltages = np.linspace(int(float(rect[0])),int(float(rect[2])),dimX)\r\n    y_voltages = np.linspace(int(float(rect[1])),int(float(rect[3])),dimY)\r\n    \r\n    x_deg = x_voltages * 2.5 * np.pi / 180   \r\n    y_deg = y_voltages * 2.5 * np.pi / 180 #OBS: minus sign on y might be a relic/pr needed. Check images against reality\r\n\r\n    return x_deg, y_deg\r\n\r\n\r\n#------- Functions for plotting and saving data ------- \r\ndef scatter(d_data, file, cutoff, name = \"\",save = True):\r\n    #Produces a 3d scatterplot of the generated data and saves it\r\n    Xdata , Ydata, Zdata = [], [], []\r\n    for p in d_data:\r\n        Xdata.append(p[0])\r\n        Ydata.append(p[1])\r\n        Zdata.append(d_data[p])\r\n        \r\n    fig = plt.figure(figsize=(15,15))\r\n    ax = fig.add_subplot(111,projection=\"3d\")\r\n\r\n    #### Colour scheme ##### Some nice colour gradients to use\r\n    C = {\"#4568DC\" : \"#B06AB3\"#(blue to purple)  \r\n        ,\"#C33764\" : \"#1D2671\" #(pink to blue)\r\n        ,\"#00F260\" : \"#0575E6\" #(green to blue) \r\n        ,\"#bc4e9c\" : \"#f80759\" #(purple to pink)\r\n        ,\"#333333\" : \"#dd1818\" # (dark to red) \r\n        ,\"#009FFF\" : \"#ec2F4B\" #(blue to red)\r\n        ,\"#654ea3\" : \"#eaafc8\" #(ultraviolet)\r\n        ,\"#a8ff78\" : \"#78ffd6\" #can't remember)\r\n        ,\"#005AA7\" : \"#FFFDE4\" #(blue to white)\r\n        ,\"#0bf91f\" : \"#ff002c\" #(green to red)\r\n        }\r\n    \r\n    \"\"\"\r\n    Code block assigns a color to every point. No real information is stored in this color, it simply makes the images nicer and easier to read\r\n    \"\"\"\r\n    range = len(Zdata)\r\n    key = random.choice(list(C.keys())) #A random choice of gradient is possible\r\n    key = \"#0bf91f\"  #I found a colour gradient I like best\r\n    primer = Color(key)\r\n    base = Color(C[key])\r\n    colors = list(primer.range_to(base, range ))\r\n    \r\n    zmin = np.min(Zdata)\r\n    zmax = np.max(Zdata)\r\n\r\n    zcol = np.round( (Zdata-zmin) / (zmax-zmin) * range - 1)\r\n    col = []\r\n\r\n    for num in zcol:\r\n        col += [colors[int(num)].rgb]\r\n    \r\n    ##### Cleaning some of the data to avoid squished plots ####\r\n    avg = np.mean([i for i in Zdata if not np.isnan(i)])\r\n    std = np.std([i for i in Zdata if not np.isnan(i)])\r\n\r\n    Zdata = [i if i > avg-cutoff*std and i < avg+cutoff*std else np.NaN for i in Zdata ]\r\n    #Value of cutoff is asigned in ETA frontend because I was annoyed of digging through the code to change it all the time\r\n    \r\n    ax.scatter(Ydata,Zdata,Xdata, c = col ,s=2) #Plots the data\r\n    #ax.azim = int(z_rot) #sets a rototion of the plot if needed, not used much\r\n    #ax.elev = int(x_rot)\r\n    \r\n    #ax.set_title(\"3D reconstruction\", fontsize = 40)\r\n    ax.set_xlabel(\"mm\", fontsize = 40, labelpad=40)\r\n    ax.set_ylabel(\"mm\", fontsize = 40, labelpad=40)\r\n    ax.set_zlabel(\"mm\", fontsize = 40, labelpad=40)\r\n    \r\n    ax.tick_params(labelsize=30)\r\n    \r\n    #Saves the data\r\n    if save: #Do you want to save the picture?\r\n        if not os.path.exists(file.parent.joinpath(f'analyzed_images')): #If folder does not exist, create it\r\n            os.makedirs(file.parent.joinpath(f'analyzed_images'))\r\n        \r\n        #Code block generates a new name for the image in order to not save over old results        \r\n        folder = str(file.parent.joinpath(f'analyzed_images'))\r\n        filename = name+file.stem+'_3Dplot.png'\r\n        directory = os.fsencode(folder)\r\n        FILES = [os.fsdecode(f) for f in os.listdir(directory)]\r\n        i = 2\r\n        while str(filename) in FILES:\r\n            filename = name+file.stem+'_3Dplot_' +str(i)+  '.png'\r\n            i+=1\r\n            \r\n        \r\n        savepath = file.parent.joinpath(f'analyzed_images', filename)\r\n        fig.savefig(savepath) # needs path\r\n    \r\n    plt.close('all')\r\n\r\n \r\ndef save_pixel(histogram,file,x,y):\r\n    #Saves a single pixel (x,y), used mainly for trouble shooting and diagnosing\r\n    if not os.path.exists(file.parent.joinpath(f'analyzed pixels')):\r\n        os.makedirs(file.parent.joinpath(f'analyzed pixels'))\r\n    \r\n    savepath = file.parent.joinpath(f'analyzed pixels', f'pixel_x={x}_y={y}.txt')\r\n    np.savetxt(savepath,np.transpose([np.arange(0,histogram[x][y].size)*binsize,histogram[x][y]]))\r\n\r\ndef save_pixel_array(histogram,file):\r\n    #Saves several pixels for diagnosing and trouble shooting the algorithm\r\n    for i in range (9):\r\n        x = random.randint(0,dimX-1)\r\n        y = random.randint(0,dimY-1)\r\n        \r\n        save_pixel(histogram,file,x,y)\r\n    \r\ndef save_data(d_data, file, name):\r\n    #Saves the X,Y,Z data in a text file\r\n    Xdata , Ydata, Zdata = [], [], []\r\n    for p in d_data:\r\n        Xdata.append(p[0])\r\n        Ydata.append(p[1])\r\n        Zdata.append(d_data[p])\r\n        \r\n    #Saves the data\r\n    if not os.path.exists(file.parent.joinpath(f'3d data')): #If folder does not exist, create it\r\n        os.makedirs(file.parent.joinpath(f'3d data'))\r\n    \r\n    filename = name+file.stem\r\n    savepath = file.parent.joinpath(f'3d data', filename)\r\n    np.savetxt(savepath,np.transpose([Xdata,Ydata,Zdata]))\r\n    \r\n#-------  Functions to fit plots to data ------- \r\ndef gauss(x,y,ref):\r\n    #Fits a Gaussian curve to the data\r\n    supermodel = ConstantModel()+GaussianModel() #Sets the model to fit. The constant model is neded to decrease sensitivity to background noise\r\n    #Guesses for start parameters\r\n    a_peak = np.max(y)\r\n    t_peak = np.where(y == a_peak)[0][0]*binsize\r\n    avg = np.mean(y)\r\n    params = supermodel.make_params(amplitude=a_peak*(22*np.sqrt(2*np.pi)),\r\n                                    center=t_peak, sigma=22, c=3)\r\n    \r\n    result = supermodel.fit(y, params=params, x=x)\r\n    center = result.params['center'].value\r\n    height = result.params['amplitude'].value\r\n    return calcDistance(center,ref*binsize), height\r\n\r\ndef skewedgauss(x,y, ref):\r\n    #Fits a SkewedGaussian function to the data\r\n    #Acheives slightly better result on individual pixels but overal performance is worse, not sure why. Probably due to higher sensitivity\r\n    \r\n    supermodel = ConstantModel() + SkewedGaussianModel() #The constant model is neded to decrease sensitivity to background noise\r\n    \r\n    # Start guesses for parameters\r\n    a_peak = np.max(y)\r\n    t_peak = np.where(y == a_peak)[0][0]*binsize\r\n    avg = np.mean(y)\r\n    gamma = 1.5\r\n    sigma = 30\r\n\r\n    params = supermodel.make_params(amplitude = a_peak*sigma*np.sqrt(2*np.pi),\r\n                                    center = t_peak,\r\n                                    sigma = sigma,\r\n                                    gamma = gamma,\r\n                                    c = 3)\r\n\r\n    result = supermodel.fit(y, params = params, x = x)\r\n    center = result.params['center'].value\r\n    return calcDistance(center,ref*binsize)\r\n    \r\n\r\n\r\n#------------- Run Variables ---------------------\r\nref = int(index_ref) # Reference peak close to Galvo. (for 780x16)\r\nbackground_cutoff = int(index_cutoff) # Index where background reflections are gone.(for 780x16)\r\ntime = (np.arange(0,histogram[0][0].size)*binsize)\r\n\r\ndimX = int(float(dimX))\r\ndimY = int(float(dimY))\r\n\r\n#----------------- Scan variables ---------------------\r\n#Variable that were used when scanning. What region was scanned and how many points\r\nrect = rect.strip('][').split(',')\r\nx_deg, y_deg = angles(rect,dimX,dimY)\r\n\r\n\r\n#--------------- Analysing the ToF histograms -----------\r\ndef analyse(histogram):\r\n    d_data = {}  #used to store the data\r\n    average_peak = 0  #some fun values to keep track of\r\n    average_failed_peak = 0 #some fun values to keep track of\r\n    \r\n    F = 0   #Used to keep track of the number of failed pixels\r\n    start = t.time() #Evaluate the time efficiency of the algorithms\r\n    \r\n    \"\"\"\r\n    Code block loops through all histograms. Removes background/internal reflections and calculates the distance to a reference value that must be measured separately (but is reused for all scans)\r\n    \"\"\"\r\n    for i in range(0,len(y_deg)):\r\n        print(i,\"/\",len(y_deg))\r\n        for j in range(0,len(x_deg)):\r\n            h = histogram[j][i]\r\n            h[:background_cutoff] = 0 #Cuts away the internal reflections, background_cutoff is assigned in ETA frontend and is based on a background measurement. \r\n            \r\n            peak = np.amax(h) #Identifies the target peak\r\n            if peak > 5:  #removes pixels with only noise, noise threshold can be modified\r\n                \r\n                #dFit, _ = gauss(time,h,ref) #Gaussian algorithm\r\n                dFit = getDistance(ref, h)  #Peak finding Algorithm\r\n                if dFit != np.NaN: #Gaussian algorithm can return np.NaN if unable to fit a curve to data, very unlikely after filtering away peaks with. It's a relic and might be obselete (but it's not hurting anyone)\r\n                    \r\n                    xf,yf,zf = XYZ(np.abs(dFit),x_deg[i],y_deg[j])\r\n                    d_data[(xf,yf)] = zf\r\n                \r\n                average_peak += peak \r\n            else:\r\n                F +=1\r\n                average_failed_peak += peak\r\n                \r\n    stop = t.time()\r\n    print(\"Analysis time: \", stop-start)\r\n    print(\"Failed pixels: \", F)\r\n    print(\"Average peak: \", average_peak/(dimY*dimX - F))\r\n    if F!=0:\r\n        print(\"Average failed peak: \", average_failed_peak/F)\r\n    \r\n    return d_data\r\n    \r\n\r\n#save_pixel_array(histogram, file) #To save some raw data for troubleshooting\r\nd_data = analyse(histogram)\r\nprint(\"Total Analysis time: \", t.time()-START)\r\n#-------------------- Save code -------------\r\nprint(\"Saving Images\")\r\ncoff = int(coff) # prevents the images from being to squished\r\n\r\n\r\nscatter(d_data, file, coff,save_name+\"_Fit_\")\r\nsave_data(d_data, file, save_name + '_')\r\n\r\nprint(\"Job Done!\")\r\n","eta_index_table":"[{\"id\":\"var_templatejkim3bkj\",\"name\":\"file\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"C:/Users/vLab/Desktop/Lidar/resolution_jitterUppgrade_10ms_10MHz_200KHzCts_16.7uA_[8,8,-8,-8]_100x100_210706.timeres\"},{\"id\":\"var_templatekl6exoyq\",\"name\":\"save_name\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"peak\"},{\"id\":\"var_templatejkim48wp\",\"name\":\"binsize\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkim2z6x\",\"name\":\"bins\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"6250\"},{\"id\":\"var_templatejkim6uch\",\"name\":\"expname\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"3D\"},{\"id\":\"var_templatejks89alb\",\"name\":\"ch_sel\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"t1\"},{\"id\":\"var_templatek1wj6afv\",\"name\":\"records_per_cut\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"2e5\"},{\"id\":\"var_templatek8k93yir\",\"name\":\"delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k9432h\",\"name\":\"fw_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k94746\",\"name\":\"bw_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatekl81i2po\",\"name\":\"sync_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatekippt2ni\",\"name\":\"rect\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"[8,8,-8,-8]\"},{\"id\":\"var_templatekipptn7c\",\"name\":\"dimX\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"100\"},{\"id\":\"var_templatekiq1qw9x\",\"name\":\"dimY\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"100\"},{\"id\":\"var_templatekippu799\",\"name\":\"index_ref\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"1996\"},{\"id\":\"var_templatekir5s2pd\",\"name\":\"index_cutoff\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"2000\"},{\"id\":\"var_templatekl83xm66\",\"name\":\"z_rot\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"270\"},{\"id\":\"var_templatekl85yl1r\",\"name\":\"x_rot\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"20\"},{\"id\":\"var_templatekmvv0jz2\",\"name\":\"coff\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"3\"},{\"id\":\"dpp_template_code\",\"name\":\"display\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatejks7yt8a\",\"name\":\"delay1-8\",\"group\":\"quTAG\",\"info\":\"游닌[1] 游닋[8] \",\"config\":\"\"},{\"id\":\"vi_templatekkzm437v\",\"name\":\"delay3-9\",\"group\":\"quTAG\",\"info\":\"游닌[3] 游닋[9] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlupxy\",\"name\":\"delay5-10\",\"group\":\"quTAG\",\"info\":\"游닌[5] 游닋[10] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlp8yt\",\"name\":\"Lidar (start=ch10, stop=ch8)[t1]\",\"group\":\"quTAG\",\"info\":\"游닌[10, 8, 102, 103] \",\"config\":\"\"},{\"id\":\"vi_templatekbz00gz5\",\"name\":\"Lidar (start=ch10, stop=ch9)[t2]\",\"group\":\"quTAG\",\"info\":\"游닌[10, 9, 102, 103] \",\"config\":\"\"},{\"id\":\"vi_templatekbz03aiq\",\"name\":\"Lidar (start=ch10, stop=ch8, ch9)[t3]\",\"group\":\"quTAG\",\"info\":\"游닌[10, 8, 9, 102, 103] \",\"config\":\"\"},{\"id\":\"vi_templatek6z86r0w\",\"name\":\"Time Tagger\",\"group\":\"quTAG\",\"info\":\"游닆[0, 1, 2, 3, 4, 5] \",\"config\":\"\"}]","vi_templatejhrlp8yt":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":364,\"y\":214,\"fixed\":true,\"text\":\"started\",\"marked\":true,\"px\":364,\"py\":214},{\"x\":143,\"y\":405,\"weight\":1,\"fixed\":true,\"text\":\"Moving\",\"px\":143,\"py\":405},{\"x\":143,\"y\":522,\"weight\":1,\"fixed\":true,\"text\":\"Done\",\"px\":143,\"py\":522}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":0,\"text\":\"8\"},{\"source\":1,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":2,\"text\":\"102\"},{\"source\":2,\"target\":3,\"text\":\"102\"},{\"source\":2,\"target\":1,\"text\":\"103\"},{\"source\":0,\"target\":2,\"text\":\"102\"},{\"source\":0,\"target\":0,\"text\":\"8\"}],\"usercode\":\"CLOCK(c1)\\nINTEGER(X)\\nINTEGER(Y)\\nINTEGER(pixelnumber)\\nHISTOGRAM(t1, (`bins`, `binsize`), [`dimX`,`dimY`])\\n\\nMoving--103-->started:\\n    {\\n        pixelnumber+=1\\n        #print(X)\\n        #print(Y)\\n        x_counter_fwd = pixelnumber % `dimX`\\n        x_counter_bwd = `dimX`-x_counter_fwd-1\\n        Y = int(np.floor(pixelnumber / `dimX`))\\n        X = x_counter_fwd if Y%2 == 0 else x_counter_bwd\\n        conditional = int(pixelnumber == int(`dimX`)*int(`dimX`)+1)\\n    }\\n    \\nstopped:\\n    c1.stop()\\n    t1[X][Y].record(c1)\\n    \\nstarted:\\n    c1.start()\\n    \\nDone:\\n    abort()\"}","vi_templatejhrlupxy":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"5\"}],\"usercode\":\"a:\\n    emit(10,`sync_delay`)# here, ch2 is duplicated to ch9 with a delay of bw_delay ps\"}","var_templatejkim2z6x":null,"var_templatejkim3bkj":null,"var_templatejkim48wp":null,"var_templatejkim6uch":null,"vi_templatejks7yt8a":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(8,`fw_delay`) # here, ch1 is duplicated to ch8 with a delay of fw_delay ps\"}","var_templatejks89alb":null,"var_templatek1wj6afv":null,"vi_templatek6z86r0w":"{\"nodes\":[{\"x\":135,\"y\":77,\"fixed\":true,\"initial\":true,\"px\":135,\"py\":77}],\"edges\":[],\"usercode\":\"RFILE(timetagger1,[0,1,2,3,4,5])\"}","var_templatek8k93yir":null,"var_templatek8k9432h":null,"var_templatek8k94746":null,"vi_templatekbz00gz5":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":436,\"y\":235,\"fixed\":true,\"text\":\"started\",\"marked\":true,\"px\":436,\"py\":235},{\"x\":147,\"y\":394,\"weight\":1,\"fixed\":true,\"text\":\"Moving\"},{\"x\":148,\"y\":495,\"weight\":1,\"fixed\":true,\"text\":\"Done\"}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":0,\"text\":\"9\"},{\"source\":1,\"target\":1,\"text\":\"10\"},{\"source\":0,\"target\":0,\"text\":\"9\"},{\"source\":0,\"target\":2,\"text\":\"102\"},{\"source\":2,\"target\":1,\"text\":\"103\"},{\"source\":1,\"target\":2,\"text\":\"102\"},{\"source\":2,\"target\":3,\"text\":\"102\"}],\"usercode\":\"CLOCK(c2)\\nINTEGER(X2)\\nINTEGER(Y2)\\nINTEGER(pixelnumber2)\\nHISTOGRAM(t2, (`bins`, `binsize`), [`dimX`,`dimY`])\\n\\n\\nMoving--103-->started:\\n    {\\n        pixelnumber2+=1\\n        #print(X)\\n        #print(Y)\\n        x_counter_fwd = pixelnumber2 % `dimX`\\n        x_counter_bwd = `dimX`-x_counter_fwd-1\\n        Y2 = int(np.floor(pixelnumber2 / `dimX`))\\n        X2 = x_counter_fwd if Y%2 == 0 else x_counter_bwd\\n        conditional = int(pixelnumber2 == int(`dimX`)*int(`dimX`)+1)\\n    }\\n    \\nstarted:\\n    c2.start()\\nstopped:\\n    c2.stop()\\n    t2[X2][Y2].record(c2)\"}","vi_templatekbz03aiq":"{\"nodes\":[{\"x\":130,\"y\":161,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true,\"px\":130,\"py\":161},{\"x\":287,\"y\":279,\"fixed\":true,\"text\":\"started\",\"marked\":true,\"px\":287,\"py\":279},{\"x\":130,\"y\":374,\"weight\":1,\"fixed\":true,\"text\":\"Moving\"},{\"x\":129,\"y\":494,\"weight\":1,\"fixed\":true,\"px\":129,\"py\":494,\"text\":\"Done\"}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":0,\"text\":\"8,9\"},{\"source\":1,\"target\":1,\"text\":\"10\"},{\"source\":0,\"target\":2,\"text\":\"102\"},{\"source\":2,\"target\":1,\"text\":\"103\"},{\"source\":2,\"target\":3,\"text\":\"102\"},{\"source\":1,\"target\":2,\"text\":\"102\"},{\"source\":0,\"target\":0,\"text\":\"8,9\"}],\"usercode\":\"CLOCK(c3)\\nINTEGER(X3)\\nINTEGER(Y3)\\nINTEGER(pixelnumber3)\\nHISTOGRAM(t3, (`bins`, `binsize`), [`dimX`,`dimY`])\\n\\nMoving--103-->started:\\n    {\\n        pixelnumber3+=1\\n        #print(X)\\n        #print(Y)\\n        x_counter_fwd = pixelnumber3 % `dimX`\\n        x_counter_bwd = `dimX`-x_counter_fwd-1\\n        Y3 = int(np.floor(pixelnumber3 / `dimX`))\\n        X3 = x_counter_fwd if Y%2 == 0 else x_counter_bwd\\n        conditional = int(pixelnumber3 == int(`dimX`)*int(`dimX`)+1)\\n    }\\n    \\nstopped:\\n    c3.stop()\\n    t3[X3][Y3].record(c3)\\n    \\nstarted:\\n    c3.start()\\n    \\nDone:\\n    abort()\"}","var_templatekippt2ni":null,"var_templatekipptn7c":null,"var_templatekippu799":null,"var_templatekiq1qw9x":null,"var_templatekir5s2pd":null,"vi_templatekkzm437v":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"3\"}],\"usercode\":\"a:\\n    emit(9,`bw_delay`)# here, ch2 is duplicated to ch9 with a delay of bw_delay ps\"}","var_templatekl6exoyq":null,"var_templatekl81i2po":null,"var_templatekl83xm66":null,"var_templatekl85yl1r":null,"var_templatekmvv0jz2":null}